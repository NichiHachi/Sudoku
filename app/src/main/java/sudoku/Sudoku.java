/*
 * This source file was generated by the Gradle 'init' task
 */
package sudoku;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

public class Sudoku {
    ArrayList<Rule> rules;
    ArrayList<Set<Position>> rulesPosition;
    Position offsetPosition;
    Position size;

    public Sudoku(int size, Position offsetPosition){
        this.size = new Position(size);
        this.offsetPosition = offsetPosition;
        this.rules = new ArrayList<>();
        this.rulesPosition = new ArrayList<>();
    }

    public Sudoku(int size, int diagonalOffsetPosition){
        this(size, new Position(diagonalOffsetPosition));
    }

    public Sudoku(int size){
        this(size, new Position(0));
    }

    public Sudoku(int size, String[] values, Position caseSize, Position diagonalOffsetPosition){
        this(size, diagonalOffsetPosition);

        if(values.length < size){
            System.err.println("[Sudoku] There are less value than there is columns and lines on the Sudoku");
            return;
        }

        if(size % caseSize.getX() > 0 || size % caseSize.getY() > 0){
            System.err.println("[Sudoku] The size of each case " + caseSize + " can't build a Sudoku of size " + size);
            return;
        }

        this.initWithValues(values, caseSize);
        this.initColumnsLines();
    }

    public Sudoku(String[] values, Position offsetPosition){
        this(values.length, values, new Position((int) Math.sqrt(values.length)), offsetPosition);
    }

    public Sudoku(String[] values, int diagonalOffsetPosition){
        this(values, new Position(diagonalOffsetPosition));
    }

    public Sudoku(String[] values){
        this(values, 0);
    }

    public ArrayList<Rule> getRules(){
        return this.rules;
    }

    public ArrayList<Set<Position>> getRulesPositions(){
        return this.rulesPosition;
    }

    public Position getSize() {
        return this.size;
    }

    public Position getMinPosition(){
        return this.offsetPosition;
    }

    public Position getMaxPosition(){
        return this.offsetPosition.add(this.size);
    }

    private boolean isInsideOfSudoku(Position position){
        return position.getX() >= 0 && position.getY() >= 0
                && position.getX() < this.size.getX() && position.getY() < this.size.getY();
    }

    public void add(Rule rule, ArrayList<Position> rulePositions){
        this.rules.add(rule);
        // Changing the position to the absolute position because it is useless to stock it as it is.
        Set<Position> ruleAbsolutePos = new HashSet<>();
        for(Position pos : rulePositions){
            if (!isInsideOfSudoku(pos)){
                System.err.println("Sudoku: The position is outside of the Sudoku, cancel the addition of the rule.");
                return;
            }
            ruleAbsolutePos.add(pos.add(this.offsetPosition));
        }
        this.rulesPosition.add(ruleAbsolutePos);
    }

    public int getNumberRule(){
        return this.rules.size();
    }

    public Rule getRule(int index){
        return this.rules.get(index);
    }

    public Set<Position> getRulePositions(int index){
        return this.rulesPosition.get(index);
    }

    public void remove(Rule rule){
        int index = this.rules.indexOf(rule);
        this.rules.remove(index);
        this.rulesPosition.remove(index);
    }

    public void initColumnsLines(){
        Set<String> values = new HashSet<>();
        for(Rule rule : this.rules){
            values.addAll(rule.getPossibleMove());
        }
        this.initColumnsLines(values.toArray(new String[0]));
    }

    private void initColumnsLines(String[] values){
        for(int x=0; x<this.size.getX(); x++){
            Rule rule = new Rule(values);

            ArrayList<Position> positions = new ArrayList<>();
            for(int y=0; y<this.size.getY(); y++){
                positions.add(new Position(x,y));
            }

            this.add(rule, positions);
        }

        for(int y=0; y<this.size.getY(); y++){
            Rule rule = new Rule(values);

            ArrayList<Position> positions = new ArrayList<>();
            for(int x=0; x<this.size.getX(); x++){
                positions.add(new Position(x,y));
            }

            this.add(rule, positions);
        }
    }

    private void initWithValues(String[] values, Position caseSize){
        int nbrColumn = this.size.getX() / caseSize.getX();
        int nbrLine = this.size.getY() / caseSize.getY();
        for(int y=0; y<nbrLine; y++){
            for(int x=0; x<nbrColumn; x++){
                Rule rule = new Rule(values);
                ArrayList<Position> positions = new ArrayList<>();
                for(int yLocal=0; yLocal<caseSize.getY(); yLocal++){
                    for(int xLocal=0; xLocal<caseSize.getX(); xLocal++){
                        positions.add(new Position(x * caseSize.getX() + xLocal,
                                y * caseSize.getY() + yLocal));
                    }
                }
                this.add(rule, positions);
            }
        }
    }
}
